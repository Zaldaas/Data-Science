# -*- coding: utf-8 -*-
"""Zeid Aldaas Homework 7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CauqJJUN212ZNUE3H57A1IMvSy70o6D7
"""

# 1. What would the 1-Nearest Neighbor approach predict is the class when the feature set is {Soymilk, Apple, Eggs} and the following data is used as the training data (same table as the classwork)? Use the Jaccard similarity to calculate neighbors. Show your calculations. (Note: do NOT write any code for this problem. The answers are to be computed by hand.)
'''
Jaccard¬†Similarity= ‚à£A‚à™B‚à£ / ‚à£A‚à©B‚à£

Row A: {Apple, Banana, Soymilk, Yogurt}
Intersection: {Apple, Soymilk} (2 elements)
Union: {Apple, Banana, Soymilk, Yogurt, Eggs} (5 elements)
Jaccard Similarity: 2 / 5 = 0.4

‚ÄãRow B: {Apple, Peanuts, Yogurt}
Intersection: {Apple} (1 element)
Union: {Apple, Peanuts, Yogurt, Soymilk, Eggs} (5 elements)
Jaccard Similarity: 1 / 5 = 0.2
‚Äã
Row C: {Tomatoes, Potatoes, Yogurt}
Intersection: {} (0 elements)
Union: {Tomatoes, Potatoes, Yogurt, Soymilk, Apple, Eggs} (6 elements)
Jaccard Similarity: 0 / 6 = 0

Row D: {Apple, Tomatoes, Potatoes}
Intersection: {Apple} (1 element)
Union: {Apple, Tomatoes, Potatoes, Soymilk, Eggs} (5 elements)
Jaccard Similarity: 1 / 5 = 0.2

Nearest Neighbor = Row A because it has the highest Jaccard Similarity
Class of Row A is Vegetarian

ANSWER: Vegetarian
'''

# 2. Consider the following dataset. (Note: do NOT write any code for this problem. The answers are to be computed by hand and marked on the graph. You can visually guess some of the answers.)
# e. Will the k-means algorithm terminate after this first iteration or will it continue? Answer in 1-2 sentences.
# ANSWER: The k-means algorithm will continue. Since the cluster centers have changed from the initial positions, the algorithm will perform additional iterations to verify if further adjustments to the centers are needed, eventually converging when the centers no longer change.
# f. If a new point (Length=140, Width=60) is given, to which cluster will it belong?
'''
To determine the closest cluster for the new point (140, 60):
Distance to New Center 1 (130, 70):
d = sqrt((140‚àí130)^2 + (60‚àí70)^2) ‚âà 14.14
Distance to New Center 2 (170, 30):
d = sqrt((140‚àí170)^2 + (60‚àí30)^2) ‚âà 42.43

Since the new point (140, 60) is closer to New Center 1 (130, 70), it would belong to Cluster 1.
'''
# a-d.
from google.colab import files
from IPython.display import Image
Image(filename="2.png")

# 3. Consider the file breast-cancer-wisconsin.csv (in the K-means clustering; Evaluation metrics module on Canvas) which contains ‚ÄúFeatures computed from a digitized image of a fine needle aspirate (FNA) of a breast mass.‚Äù The goal is to cluster the data based on the features to distinguish Benign and Malignant cases.
# a. Read the data from the file into an object called ‚Äúmydata‚Äù. Column 1 (‚ÄúCode‚Äù) is the anonymized subject code and will not be used here. Columns 2-10 are the 9 features. Column 11 is the diagnosis: [B]enign or [M]alignant.
!pip install pandas
import pandas as pd
mydata = pd.read_csv("breast-cancer-wisconsin.csv")
# i. How many total cases are there in the data?: ___
total_cases = mydata.shape[0]
print(f"Total cases: {total_cases}")
# ii. How many [B]enign cases are there in the data?: ___
benign_cases = mydata[mydata['Class'] == 'B'].shape[0]
print(f"Benign cases: {benign_cases}")
# iii. How many [M]alignant cases are there in the data?: ___
malignant_cases = mydata[mydata['Class'] == 'M'].shape[0]
print(f"Malignant cases: {malignant_cases}")

# b. Run k-means clustering using all the rows and only the following features: ClumpThickness, CellSize, and Nuclei. Use nstart=10.
# i. What should be the value of k? k = ___
# ANSWER: In this context, since we are trying to cluster benign and malignant cases, it makes sense to set ùëò = 2 because we have two classes (Benign and Malignant). We will proceed with ùëò = 2.
# ii. Give Python code:
from sklearn.cluster import KMeans

features = mydata[['ClumpThickness', 'CellSize', 'Nuclei']]

kmeans = KMeans(n_clusters=2, n_init=10, random_state=42)
kmeans.fit(features)

print("Cluster Centers:")
print(kmeans.cluster_centers_)
print("\nCluster Labels:")
print(kmeans.labels_)

# c. Evaluation: Compare the resulting clusters with the known diagnosis
# i & ii. What is the contingency table of your clustering? (Hint: use the scikit-learn confusion_matrix() function. You can arbitrarily assign cluster 1/2 to Benign/Malignant)
from sklearn.metrics import confusion_matrix

true_labels = mydata['Class'].apply(lambda x: 0 if x == 'B' else 1)

kmeans = KMeans(n_clusters=2, n_init=10, random_state=42)
kmeans.fit(features)

predicted_labels = kmeans.labels_

if sum(predicted_labels == true_labels) < sum(predicted_labels != true_labels):
    predicted_labels = 1 - predicted_labels


conf_matrix = confusion_matrix(true_labels, predicted_labels)


print("Contingency Table (Confusion Matrix):")
print(conf_matrix)

# 4. Using the contingency table that you obtained from the previous problem (3.c), calculate the following metrics (consider Malignant as the Positive class):
from sklearn.metrics import confusion_matrix, accuracy_score, precision_score, recall_score, f1_score

TN = 437  # True Negatives
FP = 7    # False Positives
FN = 20   # False Negatives
TP = 219  # True Positives

# Calculate metrics for the k-means classifier
accuracy_kmeans = (TP + TN) / (TP + TN + FP + FN)
error_rate_kmeans = 1 - accuracy_kmeans
precision_kmeans = TP / (TP + FP)
recall_kmeans = TP / (TP + FN)
f_score_kmeans = 2 * (precision_kmeans * recall_kmeans) / (precision_kmeans + recall_kmeans)

print("k-means Classifier Metrics:")
print("Accuracy:", round(accuracy_kmeans, 4))
print("Error Rate:", round(error_rate_kmeans, 4))
print("Precision:", round(precision_kmeans, 4))
print("Recall:", round(recall_kmeans, 4))
print("F-score:", round(f_score_kmeans, 4))

# Calculate metrics for the "silly" classifier (all predictions as Malignant)
# Total counts
total_cases = TN + FP + FN + TP
total_malignant = TP + FN  # All Malignant cases
total_benign = TN + FP     # All Benign cases

# Silly classifier (predicting all as Malignant)
TP_silly = total_malignant
FP_silly = total_benign
TN_silly = 0
FN_silly = 0

# Silly classifier metrics
accuracy_silly = TP_silly / total_cases
error_rate_silly = 1 - accuracy_silly
precision_silly = TP_silly / (TP_silly + FP_silly)
recall_silly = 1  # FN_silly is 0, so recall is maximized at 1
f_score_silly = 2 * (precision_silly * recall_silly) / (precision_silly + recall_silly)

print("\nSilly Classifier Metrics:")
print("Accuracy:", round(accuracy_silly, 4))
print("Error Rate:", round(error_rate_silly, 4))
print("Precision:", round(precision_silly, 4))
print("Recall:", round(recall_silly, 4))
print("F-score:", round(f_score_silly, 4))

# Commented out IPython magic to ensure Python compatibility.
def colab2pdf():
  # @title Download Notebook in PDF Format{display-mode:'form'}
  !apt-get install -yqq --no-install-recommends librsvg2-bin>/dev/null;
  import contextlib,datetime,google,io,IPython,ipywidgets,json,locale,nbformat,os,pathlib,requests,urllib,warnings,werkzeug,yaml,re;locale.setlocale(locale.LC_ALL,'en_US.UTF-8');warnings.filterwarnings('ignore',category=nbformat.validator.MissingIDFieldWarning);
#   %matplotlib inline
  def convert(b):
    try:
      s.value='üîÑ Converting';b.disabled=True
      n=pathlib.Path(werkzeug.utils.secure_filename(urllib.parse.unquote(requests.get(f'http://{os.environ["COLAB_JUPYTER_IP"]}:{os.environ["KMP_TARGET_PORT"]}/api/sessions').json()[0]['name'])))
      p=pathlib.Path('/content/pdfs')/f'{datetime.datetime.utcnow().strftime("%Y%m%d_%H%M%S")}_{n.stem}';p.mkdir(parents=True,exist_ok=True);nb=nbformat.reads(json.dumps(google.colab._message.blocking_request('get_ipynb',timeout_sec=600)['ipynb']),as_version=4)
      u=[u for c in nb.cells if c.get('cell_type')=='markdown' for u in re.findall(r'!\[.*?\]\((https?://.*?)\)',c['source']) if requests.head(u,timeout=5).status_code!=200]
      if u:raise Exception(f"Bad Image URLs: {','.join(u)}")
      nb.cells=[cell for cell in nb.cells if '--Colab2PDF' not in cell.source]
      nb=nbformat.v4.new_notebook(cells=nb.cells or [nbformat.v4.new_code_cell('#')]);nbformat.validator.normalize(nb)
      nbformat.write(nb,(p/f'{n.stem}.ipynb').open('w',encoding='utf-8'))
      with (p/'config.yml').open('w', encoding='utf-8') as f: yaml.dump({'include-in-header':[{'text':r'\usepackage{fvextra}\DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaksymbolleft={},showspaces=false,showtabs=false,breaklines,breakanywhere,commandchars=\\\{\}}'}],'include-before-body':[{'text':r'\DefineVerbatimEnvironment{verbatim}{Verbatim}{breaksymbolleft={},showspaces=false,showtabs=false,breaklines}'}]},f)
      !quarto render {p}/{n.stem}.ipynb --metadata-file={p}/config.yml --to pdf -M latex-auto-install -M margin-top=1in -M margin-bottom=1in -M margin-left=1in -M margin-right=1in --quiet
      google.colab.files.download(str(p/f'{n.stem}.pdf'));s.value=f'‚úÖ Downloaded: {n.stem}.pdf'
    except Exception as e:s.value=f'‚ùå {str(e)}'
    finally:b.disabled=False
  if not pathlib.Path('/usr/local/bin/quarto').exists():
    !wget -q 'https://quarto.org/download/latest/quarto-linux-amd64.deb' && dpkg -i quarto-linux-amd64.deb>/dev/null && quarto install tinytex --update-path --quiet && rm quarto-linux-amd64.deb
  b=ipywidgets.widgets.Button(description='‚¨áÔ∏è Download');s=ipywidgets.widgets.Label();b.on_click(lambda b:convert(b));IPython.display.display(ipywidgets.widgets.HBox([b,s]))
colab2pdf() # | Colab2PDF v1.6 | https://github.com/drengskapur/colab2pdf | GPL-3.0-or-later |